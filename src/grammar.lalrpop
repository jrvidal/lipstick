use std::str::FromStr;
use super::*;

grammar;

match {
    r"\s*" => { }, // The default whitespace skipping is disabled an `ignore pattern` is specified
    r"//[^\n\r]*[\n\r]*" => { }, // Skip `// comments`
    r"/\*([^\*]*\*+[^\*/])*([^\*]*\*+|[^\*])*\*/" => { },  // Skip `/* comments */`
} else {
  _
}

pub Program : Program = {
  <ProgramItems> => Program(<>)
}

ProgramItems: Vec<Item> = {
  <Item> => vec![<>],
  <items: ProgramItems> <item: Item> => {
    let mut items = items;
    items.push(item);
    items
  }
}

Item: Item = {
  <Function> => <>,
  <StructDecl> => <>,
  <Use> => <>
}

Use: Item = {
  "use" "::" <Ident> ";" => Item::Use(true, <>),
  "use" <Ident> ";" => Item::Use(false, <>)
}

StructDecl: Item = {
  "struct" <name: Ident> "{" <list: StructFieldList> "}" => Item::StructDecl(name, list)
}

StructFieldList: Vec<(String, Type)> = {
  <name: Ident> ":" <ty: Type> => vec![(name, ty)],
  <list: StructFieldList> "," <name: Ident> ":" <ty: Type> => {
    let mut list = list;
    list.push((name, ty));
    list
  },
  <StructFieldList> "," => <>
}

Function: Item = {
  "fn" <name: Ident> <sig: Signature> <body: Block> => Item::Function(sig, name, body)
};

Signature: Signature = {
  "(" ")" => Signature { args: vec![], ret: None  },
  "(" ")" "->" <Type> => Signature { args: vec![], ret: Some(<>) },
  "(" <SignatureArgs> ")" => Signature { args: <>, ret: None  },
  "(" <args: SignatureArgs> ")" "->" <ty: Type> => Signature { args: args, ret: Some(ty) }
}

SignatureArgs: Vec<(String, Type)> = {
  <SignatureArg> => vec![<>],
  <args: SignatureArgs> "," <arg: SignatureArg> => {
    let mut args = args;
    args.push(arg);
    args
  }
}

SignatureArg: (String, Type) = {
  <arg: Ident> ":" <ty: Type> => (arg, ty)
}

Block: Block = {
  "{" "}" => Block { statements: vec![] },
  "{" <BlockStmts> "}" => Block { statements: <> }
}

BlockStmts: Vec<Stmt> = {
  <Stmt> => vec![<>],
  <b: BlockStmts> <s: Stmt> => {
    let mut b = b;
    b.push(s);
    b
  }
}

Stmt: Stmt = {
  "let" <id: Ident> <t:("=" <Expr>)?> ";" => Stmt::UntypedDeclaration,
  "let" <id: Ident> ":" <ty: Type> "=" <expr: Expr> ";" => Stmt::Declaration(id, ty, Some(expr)),
  "let" <id: Ident> ":" <ty: Type> ";" => Stmt::Declaration(id, ty, None),
  <place: Expr> "=" <expr: Expr> ";" => Stmt::Assignment(place, expr),
  "return" <Expr?> ";" => Stmt::Return(<>),
  <Expr> ";" => Stmt::Expr(<>),
  <Block> => Stmt::Block(<>),
  <IfStmt> => Stmt::If(<>),
  "while" <IfValidExpr> <Block> => Stmt::While(<>),
  <label: Lifetime> ":" <stmt: Stmt> => Stmt::Labeled(label, stmt.into()),
  "break" <Lifetime?> ";" => Stmt::Break(<>),
  "continue" <Lifetime?> ";" => Stmt::Continue(<>),
}

IfStmt: IfStmt = {
  "if" <test: IfValidExpr> <then: Block> => IfStmt { test, then, alts: vec![], tail: None },
  "if" <test: IfValidExpr> <then: Block> "else" <tail: Block> => IfStmt { test, then, alts: vec![], tail: Some(tail) },
  "if" <test: IfValidExpr> <then: Block> "else" <stmt: IfStmt> => {
    let mut alts = stmt.alts;
    alts.insert(0, (stmt.test, stmt.then));
    IfStmt { test, then, alts, tail: stmt.tail }
  },
}

Expr: Expr = {
  IfInvalidExpr,
  IfValidExpr,
}

IfInvalidExpr: Expr = {
  <name: Ident> <init_list: StructInitFields> => Expr::StructInit(name, init_list),
}


IfValidExpr: Expr = {
  <IfValidExpr> "." <Ident> "(" ")" => Expr::MethodCall,
  <IfValidExpr> "." <Ident> "(" <ArgList> ")" => Expr::MethodCall,
  <this: IfValidExpr> "." <field: Ident> => Expr::Field(this.into(), field),
  IndexExpr
}

IndexExpr: Expr = {
  <arr: IndexExpr> "[" <index: IndexExpr> "]" => Expr::Index(arr.into(), index.into()),
  RefExpr
}

RefExpr: Expr = {
  "&" <RefExpr> => Expr::Ref(<>.into()),
  CallExpr
}

CallExpr: Expr = {
  <fun: CallExpr> "(" <args: ArgList> ","? ")" => Expr::Call(fun.into(), args),
  <CallExpr> "(" ")" => Expr::Call(<>.into(), vec![]),
  UnaryExpr
}

UnaryExpr: Expr = {
  "*" <UnaryExpr> => Expr::Deref(<>.into()),
  CastExpr
}

CastExpr: Expr = {
  <expr: CastExpr> "as" <ty: Type> => Expr::Cast(expr.into(), ty),
  AtomExpr,
}

ArgList: Vec<Expr> = {
  <Expr> => vec![<>],
  <list: ArgList> "," <expr: Expr> => {
    let mut list = list;
    list.push(expr);
    list
  }
}

AtomExpr: Expr = {
  <Ident> => Expr::Variable(<>),
  <r"-?[0-9]+"> => Expr::Integer(i64::from_str(<>).unwrap()),
  // TODO: do well
  <r#""[^"]*""#> => Expr::String(<>.to_string()),
  "true" => Expr::Boolean(true),
  "false" => Expr::Boolean(false),
  "(" <Expr> ")"  => <>
}

StructInitFields: Vec<(String, Expr)> = {
  "{" <StructInitNakedFields> ","? "}" => <>,
}

StructInitNakedFields: Vec<(String, Expr)> = {
  <name: Ident> ":" <expr: Expr> => vec![(name, expr)],
  <list: StructInitNakedFields> "," <name: Ident> ":" <expr: Expr> => {
    let mut list = list;
    list.push((name, expr));
    list
  }
}

Ident: String = {
  <r"[_a-zA-Z][_a-zA-Z0-9]*"> => <>.to_string()
}

Lifetime: String = {
  <r"'[_a-zA-Z][_a-zA-Z0-9]*"> => <>[1..].to_string()
}

Type: Type = {
  <Ident> => Type::Ident(<>),
  "&" <Type> => Type::Ref(<>.into()),
  "fn" "(" <args: TypeArgs> ","? ")" <ret: ("->" <Type>)?> => Type::Fun(args, ret.map(Box::new)),
  "[" <ty: Type> ";" <expr: Expr> "]" => Type::Array(ty.into(), expr.into()),
}

TypeArgs: Vec<Type> = {
  <Type> => vec![<>],
  <args: TypeArgs> "," <ty: Type> => {
    let mut args = args;
    args.push(ty);
    args
  }
}
